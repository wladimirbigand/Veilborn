<!doctype html>
<html lang="fr" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Veilborn • Accueil</title>
  <meta name="description" content="Entrez dans l'univers de Veilborn : histoire principale et téléchargement direct.">
  <meta name="author" content="Veilborn">
  <link rel="icon" href="/assets/favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Runic&display=swap" rel="stylesheet">
  <style>
    :root{ --brand:#8e7fff; --brand-2:#36d1dc; }
    html,body{ height:100%; scroll-behavior:smooth; margin:0; }
    body{ display:flex; flex-direction:column; background-color:#000; color:#fff; }
    .btn-runes{ 
      background:linear-gradient(90deg,var(--brand),var(--brand-2)); 
      border:0; 
      color:#111; 
      font-weight:700;
      box-shadow:0 0 16px rgba(142,127,255,.25);
      transition:filter .2s ease, transform .2s ease;
    }
    .btn-runes:hover{ 
      filter:brightness(1.1); 
      transform:translateY(-2px);
      box-shadow:0 0 24px rgba(142,127,255,.45);
    }
    .hero{ position:relative; flex:1; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; overflow:hidden; min-height:100vh; }
    .hero::before{ content:""; position:absolute; inset:0; z-index:-3; background:url('/assets/hero-veilborn.jpg') center/cover no-repeat; filter:brightness(.6); }
    .hero::after{ content:""; position:absolute; inset:0; z-index:-2; background:linear-gradient(180deg, rgba(0,0,0,.4), rgba(0,0,0,.9)); }
    .hero-logo{ max-width:360px; width:40%; height:auto; animation:fadeIn 1.2s ease forwards; }
    .hero p.lead{ max-width:60ch; margin:1.2rem auto; opacity:.9; }
    @keyframes fadeIn{ from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:translateY(0);} }
    .runes-canvas{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:-1; }
    footer{ text-align:center; padding:1rem; font-size:.9rem; opacity:.75; border-top:1px solid rgba(255,255,255,.08); }
    .back-to-top{ position:fixed; right:16px; bottom:16px; z-index:1040; display:grid; place-items:center; width:44px; height:44px; border-radius:12px; background:#1a1f2b; color:#fff; text-decoration:none; border:1px solid rgba(255,255,255,.08); }
    .back-to-top:hover{ background:#202638; }
  </style>
</head>
<body>
  <header class="hero">
    <canvas id="runesCanvas" class="runes-canvas" aria-hidden="true"></canvas>
    <img src="Assets/VeilbornLogo.png" alt="Logo Veilborn" class="hero-logo">
    <p class="lead">Un monde de brumes, de runes et de serments anciens.</p>
    <button class="btn btn-runes btn-lg mt-3" data-bs-toggle="modal" data-bs-target="#downloadModal">
      <i class="bi bi-download me-2"></i>Télécharger
    </button>
  </header>

  <footer>© <span id="year"></span> Veilborn. Tous droits réservés.</footer>

  <a href="#top" class="back-to-top" aria-label="Retour en haut" title="Retour en haut"><i class="bi bi-arrow-up-short fs-3"></i></a>

  <div class="modal fade" id="downloadModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content bg-body">
        <div class="modal-header">
          <h5 class="modal-title"><i class="bi bi-shield-lock me-2"></i>Téléchargement protégé</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <form id="downloadForm" novalidate>
          <div class="modal-body">
            <label for="dlPassword" class="form-label">Clé d'accès</label>
            <input type="password" class="form-control" id="dlPassword" placeholder="Saisissez une clé d'accès" required>
            <div class="invalid-feedback">Veuillez saisir une clé valide.</div>
            <div id="dlError" class="text-danger small mt-2 d-none">Mot de passe incorrect.</div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="submit" class="btn btn-runes">Continuer</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    const DOWNLOAD_URL="Assets/VeilBorn_V1.zip",REDIRECT_URL="merci.html",PASSWORD_HASH_HEX="e561182894f4b6daf90468eb7e75720972cb25013c89ff9bed838d955513c276";
    function toHex(b){return Array.from(new Uint8Array(b)).map(x=>x.toString(16).padStart(2,'0')).join('');}
    async function sha256Hex(s){return toHex(await crypto.subtle.digest('SHA-256',new TextEncoder().encode(s)));}
    document.getElementById('year').textContent=new Date().getFullYear();
    const f=document.getElementById('downloadForm'),p=document.getElementById('dlPassword'),e=document.getElementById('dlError');
    f.addEventListener('submit',async ev=>{ev.preventDefault();if(!f.checkValidity()){f.classList.add('was-validated');return;}
      e.classList.add('d-none');const h=await sha256Hex(p.value);
      if(h===PASSWORD_HASH_HEX.toLowerCase()){window.location.href=DOWNLOAD_URL;setTimeout(()=>window.location.href=REDIRECT_URL,2000);}
      else{e.classList.remove('d-none');p.select();}});
  </script>

  <script>
/* ==== VEILBORN RUNE RINGS — insane edition ==== */
(function(){
  const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  const hero = document.querySelector('.hero');
  const canvas = document.getElementById('runesCanvas');
  if(!hero || !canvas) return;
  const ctx = canvas.getContext('2d');

  // -------- CONFIG ----------
  const CFG = {
    colors: ['#8e7fff','#36d1dc'],        // dégradé runique
    rings: 3,                              // nb d’anneaux
    glyphsPerRing: [18, 28, 38],           // runes par anneau
    baseSpeed: [0.0010, -0.0008, 0.0002 ],  // rad/ms par anneau
    surgeBoost: 3,                       // x vitesse lors d’un surge
    surgeEveryMinMax: [6000, 11000],       // toutes les 6–11 s
    surgeDuration: 1600,                   // durée d’un surge
    minRadiusRatio: 0.18,                  // rayon min en % du min(W,H)
    ringGapRatio: 0.12,                    // écart entre anneaux
    font: "'Noto Sans Runic','Segoe UI Symbol','Inter',system-ui,sans-serif",
    glyphs: "ᚠᚢᚦᚨᚱᚲᚷᚺᚾᛁᛃᛇᛈᛉᛊᛏᛒᛖᛗᛚᛜᛞᛟᛝ✧✦✩✪☽☾",
    glowBlur: 22,
    sharpAlpha: 0.8,
    blurAlpha: 0.35,
    pulseAmp: 0.25,     // amplitude de pulsation d’opacité
    pulseSpeed: 0.0016, // vitesse de pulsation
    particleCount: 90,
    particleGlow: 14
  };

  let DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  let W=0, H=0, CX=0, CY=0, RINGS=[], PARTICLES=[];
  let rafId=null, last=performance.now();

  function resize(){
    const r = hero.getBoundingClientRect();
    W = Math.floor(r.width); H = Math.floor(r.height);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W+'px'; canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    CX = W/2; CY = H/2;
    buildScene();
    draw(performance.now());
  }

  function rand(a,b){ return a + Math.random()*(b-a); }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  function buildScene(){
    // Anneaux
    RINGS.length = 0;
    const minDim = Math.min(W,H);
    const baseR = minDim * CFG.minRadiusRatio;
    for(let i=0;i<CFG.rings;i++){
      const radius = baseR + i * (minDim*CFG.ringGapRatio);
      const n = CFG.glyphsPerRing[i] || CFG.glyphsPerRing[CFG.glyphsPerRing.length-1];
      const speed = CFG.baseSpeed[i] || CFG.baseSpeed[CFG.baseSpeed.length-1] || 0.001;
      const glyphs = new Array(n).fill(0).map((_,k)=>({
        ch: pick(CFG.glyphs),
        // décalage de phase pour la pulsation
        phase: Math.random()*Math.PI*2,
      }));
      RINGS.push({
        radius, speed, angle: rand(0,Math.PI*2),
        glyphs, surgeUntil: 0, surgeStart: 0
      });
    }
    // Particules
    PARTICLES.length = 0;
    for(let i=0;i<CFG.particleCount;i++){
      PARTICLES.push({
        x: rand(0,W), y: rand(0,H),
        vx: rand(-0.05,0.05), vy: rand(-0.05,0.05),
        a: rand(0.25,0.75), s: rand(0.8,2.2),
        c: pick(CFG.colors), t: rand(0,Math.PI*2)
      });
    }
    // planifie un surge
    scheduleSurge();
  }

  function scheduleSurge(){
    const delay = rand(...CFG.surgeEveryMinMax);
    setTimeout(()=>{
      const r = pick(RINGS);
      r.surgeStart = performance.now();
      r.surgeUntil = r.surgeStart + CFG.surgeDuration;
      // pluie d’étincelles sur la circonférence
      spawnSparksOnRing(r);
      scheduleSurge();
    }, delay);
  }

  function spawnSparksOnRing(ring){
    const count = 60;
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2);
      const rad = ring.radius + rand(-6,6);
      const x = CX + Math.cos(a)*rad;
      const y = CY + Math.sin(a)*rad;
      PARTICLES.push({
        x, y, vx: Math.cos(a)*rand(0.3,0.8), vy: Math.sin(a)*rand(0.3,0.8),
        a: 1, s: rand(1.2,2.6), c: pick(CFG.colors), t: 0, life: rand(300,700), born: performance.now()
      });
    }
  }

  function easeOutExpo(x){ return x===1 ? 1 : 1 - Math.pow(2, -10 * x); }

  function draw(now){
    const dt = now - last; last = now;
    ctx.clearRect(0,0,W,H);

    // Fond brumeux
    const g = ctx.createRadialGradient(CX,CY,0,CX,CY,Math.max(W,H)*0.7);
    g.addColorStop(0,'rgba(255,255,255,0.04)');
    g.addColorStop(1,'rgba(0,0,0,0.0)');
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // Particules (twinkle)
    for(let p of PARTICLES){
      p.x += p.vx; p.y += p.vy; p.t += 0.02;
      if(p.x<-20) p.x=W+20; if(p.x>W+20) p.x=-20;
      if(p.y<-20) p.y=H+20; if(p.y>H+20) p.y=-20;
      let alpha = p.a * (0.6+0.4*Math.sin(p.t));
      if(p.life){
        const age = now - p.born;
        if(age > p.life) { p.a=0; continue; }
        alpha *= 1 - age/p.life;
      }
      ctx.globalAlpha = Math.max(0, alpha);
      ctx.shadowColor = p.c; ctx.shadowBlur = CFG.particleGlow;
      ctx.fillStyle = p.c;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.s,0,Math.PI*2); ctx.fill();
    }
    ctx.shadowBlur=0; ctx.globalAlpha=1;

    // Anneaux de runes
    for(let r of RINGS){
      // vitesse + surge easing
      let sp = r.speed;
      if(now < r.surgeUntil){
        const t = (now - r.surgeStart)/CFG.surgeDuration;
        sp *= 1 + (CFG.surgeBoost-1)*easeOutExpo(Math.min(1,t));
      }
      r.angle += sp * dt;

      const n = r.glyphs.length;
      for(let i=0;i<n;i++){
        const th = r.angle + i*(Math.PI*2/n);
        const x = CX + Math.cos(th)*r.radius;
        const y = CY + Math.sin(th)*r.radius;

        // Pulsation douce indépendante par glyphe
        const pulse = 1 + CFG.pulseAmp*Math.sin(now*CFG.pulseSpeed + r.glyphs[i].phase);
        const size = Math.max(18, Math.min(48, (r.radius*0.06)*pulse));
        const col = CFG.colors[i%CFG.colors.length];

        ctx.save();
        ctx.translate(x,y);
        // on laisse les runes “droites” (pas tangentielles) pour mieux les lire
        ctx.rotate(0);
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font = `${size}px ${CFG.font}`;
        ctx.fillStyle = col;

        // Glow (additif), puis trace nette
        ctx.globalCompositeOperation='lighter';
        ctx.globalAlpha = CFG.blurAlpha;
        ctx.shadowColor = col; ctx.shadowBlur = CFG.glowBlur;
        ctx.fillText(r.glyphs[i].ch,0,0);

        ctx.globalAlpha = CFG.sharpAlpha;
        ctx.shadowBlur = 0;
        ctx.fillText(r.glyphs[i].ch,0,0);
        ctx.restore();
      }
    }

    if(!prefersReduced){ rafId=requestAnimationFrame(draw); }
  }

  if(prefersReduced){
    resize(); // frame statique
  } else {
    const ro = new ResizeObserver(resize);
    ro.observe(hero);
    addEventListener('orientationchange', resize, {passive:true});
    resize();
    rafId=requestAnimationFrame(draw);
    addEventListener('visibilitychange',()=>{
      if(document.hidden && rafId){ cancelAnimationFrame(rafId); rafId=null; }
      else if(!document.hidden && !rafId){ last=performance.now(); rafId=requestAnimationFrame(draw); }
    });
  }
})();
</script>

</body>
</html>
