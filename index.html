<!doctype html>
<html lang="fr" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Veilborn • Accueil</title>
  <meta name="description" content="Entrez dans l'univers de Veilborn : histoire principale, dernières mises à jour, wiki et téléchargement direct.">
  <meta name="author" content="Veilborn">
  <meta property="og:title" content="Veilborn • Accueil">
  <meta property="og:description" content="Histoire principale, mises à jour, wiki et téléchargement direct.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://veilborn.example/">
  <meta property="og:image" content="/assets/veilborn-og.jpg">
  <link rel="icon" href="/assets/favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    :root{ --brand:#8e7fff; --brand-2:#36d1dc; }
    html{ scroll-behavior:smooth; }

    .nav-link{ font-weight:600; }

    .btn-brand{ background:linear-gradient(90deg,var(--brand),var(--brand-2)); border:0; color:#111; font-weight:700; }
    .btn-brand:hover{ filter:brightness(1.06); }

    /* HERO */
    .hero{ position:relative; isolation:isolate; min-height:100vh; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; overflow:hidden; }
    .hero::before{ content:""; position:absolute; inset:0; z-index:-2; background-image: var(--hero-image, none); background-size:cover; background-position: var(--hero-position, center); filter: brightness(.6); }
    .hero::after{ content:""; position:absolute; inset:0; z-index:-1; background:linear-gradient(180deg, rgba(0,0,0,.4), rgba(0,0,0,.9)); }
    .hero-logo{ max-width:420px; width:45%; height:auto; animation: fadeIn 1.2s ease forwards; }
    .hero p.lead{ max-width:68ch; margin-inline:auto; opacity:.95; }
    @keyframes fadeIn{ from{ opacity:0; transform:translateY(12px);} to{ opacity:1; transform:translateY(0);} }

    section{ padding:72px 0; }
    .section-title{ font-weight:800; letter-spacing:.3px; }
    footer{ border-top:1px solid rgba(255,255,255,.08); }
    .back-to-top{ position:fixed; right:16px; bottom:16px; z-index:1040; display:grid; place-items:center; width:44px; height:44px; border-radius:12px; background:#1a1f2b; color:#fff; text-decoration:none; border:1px solid rgba(255,255,255,.08); }
    .back-to-top:hover{ background:#202638; }

    /* Modal small tweaks */
    .form-hint{ opacity:.75; font-size:.9rem; }

    /* --- Runes background canvas --- */
    .runes-canvas{
      position:absolute; inset:0; width:100%; height:100%;
      pointer-events:none; /* ne capte pas les clics */
      z-index:-1;          /* derrière le contenu du hero */
    }

    /* On passe l’overlay plus bas que le canvas pour que les runes soient visibles */
    .hero::after{ z-index:-2; }   /* overlay sombre */
    .hero::before{ z-index:-3; }  /* image de fond */
  </style>
</head>
<body class="bg-body text-body" data-page="accueil">

  <!-- HERO minimal avec logo + boutons -->
  <header class="hero" style="--hero-image:url('/assets/hero-veilborn.jpg'); --hero-position:center;">
    <canvas id="runesCanvas" class="runes-canvas" aria-hidden="true"></canvas>
    <!-- TODO: Remplace ce src par TON logo -->
    <img src="Assets/VeilbornLogo.png" alt="Logo Veilborn" class="hero-logo">
    <p class="lead mt-4">Un monde de brumes, de runes et de serments anciens.</p>
    <div class="d-flex flex-wrap justify-content-center gap-3 mt-4">
      <a href="wiki.html" class="btn btn-brand btn-lg"><i class="bi bi-journal-text me-2"></i>Wiki</a>
      <!-- Le bouton Download ouvre un modal (site statique, 100% JS) -->
      <button class="btn btn-outline-light btn-lg" data-bs-toggle="modal" data-bs-target="#downloadModal">
        <i class="bi bi-download me-2"></i>Télécharger
      </button>
    </div>
  </header>

  <!-- Section pitch rapide -->
  <section id="intro" class="text-center py-5">
    <div class="container">
      <h2 class="section-title mb-3">L'histoire de Veilborn</h2>
      <p class="lead">Kael s’éveille dans un monde fracturé où les Ombres dévorent la lumière. Guidé par Eryndor et la Forge de Bran, il doit tisser le Voile et restaurer l’équilibre.</p>
    </div>
  </section>

  <!-- FOOTER -->
  <footer class="py-4 text-center">
    <div class="container">
      <div class="small">© <span id="year"></span> Veilborn. Tous droits réservés.</div>
    </div>
  </footer>

  <!-- Back to top -->
  <a href="#top" class="back-to-top" aria-label="Retour en haut" title="Retour en haut"><i class="bi bi-arrow-up-short fs-3"></i></a>

  <!-- MODAL: mot de passe avant téléchargement/redirection -->
  <div class="modal fade" id="downloadModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content bg-body">
        <div class="modal-header">
          <h5 class="modal-title"><i class="bi bi-shield-lock me-2"></i>Téléchargement protégé</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fermer"></button>
        </div>
        <form id="downloadForm" class="needs-validation" novalidate>
          <div class="modal-body">
            <div class="mb-3">
              <label for="dlPassword" class="form-label">Clé d'accès</label>
              <input type="password" class="form-control" id="dlPassword" placeholder="Saisissez un clé d'accès" required>
              <div class="invalid-feedback">Veuillez saisir une clé d'accès valide !</div>
              <div id="dlError" class="text-danger small mt-2 d-none">Mot de passe incorrect.</div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="submit" class="btn btn-brand">Continuer</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // ====== CONFIG À PERSONNALISER ======
    // Remplace ces deux URLs selon ce que tu veux faire après validation :
    // - Si DOWNLOAD_URL est défini, on le télécharge/redirect en priorité
    // - Sinon si REDIRECT_URL est défini, on redirige vers cette page
    const DOWNLOAD_URL = "Assets/VeilBorn_V1.zip"; // TODO: remplace
    const REDIRECT_URL = "merci.html"; // optionnel: ex. "https://veilborn.example/merci.html"

    // Sécurité minimale côté client : compare un hash SHA-256 du mot de passe saisi
    // Génère le hash SHA-256 de ton mot de passe (en hex) et colle-le ici :
    // Exemple de hash pour le mot de passe "VEIL2025" => "7b2d2d1b64a7ef2b0d6c0b8e3a0d3f3a4f3d0c1e2c3a6b5a8d9e0f1a2b3c4d5" (placeholder)
    // (Utilise l'outil ci-dessous en console si besoin.)
    const PASSWORD_HASH_HEX = "e561182894f4b6daf90468eb7e75720972cb25013c89ff9bed838d955513c276"; // TODO: remplace par VOTRE hash

    // ====== UTILITAIRES ======
    function toHex(buffer){
      const bytes = new Uint8Array(buffer);
      return Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
    }
    async function sha256Hex(str){
      const enc = new TextEncoder().encode(str);
      const hashBuffer = await crypto.subtle.digest('SHA-256', enc);
      return toHex(hashBuffer);
    }

    // (Optionnel) Générateur rapide de hash dans la console :
    // tape: window._veilHash('MON_MDP')
    window._veilHash = async (s) => console.log(await sha256Hex(s));

    // Année dynamique
    document.getElementById('year').textContent = new Date().getFullYear();

    // Validation & logique du modal
    const form = document.getElementById('downloadForm');
    const pwdInput = document.getElementById('dlPassword');
    const err = document.getElementById('dlError');

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if(!form.checkValidity()){ form.classList.add('was-validated'); return; }
      err.classList.add('d-none');
      const entered = pwdInput.value;
      try{
        const enteredHash = await sha256Hex(entered);
        if(enteredHash === PASSWORD_HASH_HEX.toLowerCase()){
          // Succès => téléchargement ou redirection
          const target = DOWNLOAD_URL || REDIRECT_URL;
          if(target){
            // Lance le téléchargement / redirection
            window.location.href = target;
            setTimeout(() => window.location.href = REDIRECT_URL, 2000);
          } else {
            alert('Configuration manquante : définis DOWNLOAD_URL ou REDIRECT_URL.');
          }
          // Fermer le modal
          const modalEl = document.getElementById('downloadModal');
          const modal = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
          modal.hide();
          form.reset();
          form.classList.remove('was-validated');
        } else {
          err.classList.remove('d-none');
          pwdInput.select();
        }
      } catch(ex){
        console.error(ex);
        err.classList.remove('d-none');
      }
    });
  </script>
  <script>
/* ========= Veilborn Runes Background (Canvas) =========
   - Aucune dépendance
   - Respecte prefers-reduced-motion (pause anim)
   - S'adapte à la taille & au thème
   - Personnalise la densité/couleurs ci-dessous
======================================================= */

// CONFIG
const RUNES_CONFIG = {
  densityDesktop: 48,   // nombre de runes sur desktop
  densityMobile: 22,    // nombre de runes sur mobile
  minSize: 16,          // px
  maxSize: 44,          // px
  minSpeed: 0.08,       // px/frame
  maxSpeed: 0.35,       // px/frame
  rotationSpeed: 0.004, // rad/frame
  alphaMin: 0.25,
  alphaMax: 0.8,
  // Couleurs : reprend ton branding (violet -> aqua)
  colors: ['#8e7fff', '#36d1dc'],
  // Police : tente le bloc Unicode runique, sinon fallback
  fontFamily: "'Noto Sans Runic','Segoe UI Symbol','Segoe UI','Inter',system-ui,sans-serif",
  // Glyphes (Younger/ELDER Futhark + symboles mystiques)
  glyphs: "ᚠᚢᚦᚨᚱᚲᚷᚺᚾᛁᛃᛇᛈᛉᛊᛏᛒᛖᛗᛚᛜᛞᛟᛝᛇᛇᚯᚹᛇᛗᛡᛠᛣᛥ✧✦✩✪☽☾"
};

(function initVeilbornRunes(){
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const hero = document.querySelector('.hero');
  const canvas = document.getElementById('runesCanvas');
  if(!hero || !canvas) return;

  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W = 0, H = 0, RUNES = [], animId = null;

  function resize(){
    const rect = hero.getBoundingClientRect();
    W = Math.floor(rect.width);
    H = Math.floor(rect.height);
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    spawnRunes();
    draw(0); // frame statique immédiate
  }

  function rnd(a,b){ return a + Math.random()*(b-a); }
  function choice(arr){ return arr[(Math.random()*arr.length)|0]; }

  function spawnRunes(){
    const isMobile = W < 768;
    const count = isMobile ? RUNES_CONFIG.densityMobile : RUNES_CONFIG.densityDesktop;
    RUNES = [];
    for(let i=0;i<count;i++){
      const size = rnd(RUNES_CONFIG.minSize, RUNES_CONFIG.maxSize);
      const speed = rnd(RUNES_CONFIG.minSpeed, RUNES_CONFIG.maxSpeed) * (size / RUNES_CONFIG.maxSize + 0.3);
      RUNES.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vy: speed * (Math.random() < 0.5 ? 1 : -1), // monte ou descend
        vx: rnd(-0.05, 0.05),                       // légère dérive
        r: rnd(-Math.PI, Math.PI),                  // rotation initiale
        vr: (Math.random() < 0.5 ? -1 : 1)*RUNES_CONFIG.rotationSpeed*(0.6 + Math.random()*0.8),
        size,
        alpha: rnd(RUNES_CONFIG.alphaMin, RUNES_CONFIG.alphaMax),
        aPulse: rnd(0.003, 0.01) * (Math.random()<0.5?1:-1),
        glyph: choice(RUNES_CONFIG.glyphs),
        color: choice(RUNES_CONFIG.colors)
      });
    }
  }

  function draw(ts){
    ctx.clearRect(0,0,W,H);

    // voile léger pour lisser le rendu
    ctx.globalCompositeOperation = 'source-over';

    for(const ru of RUNES){
      // Update
      ru.x += ru.vx;
      ru.y += ru.vy;
      ru.r += ru.vr;
      ru.alpha += ru.aPulse;
      if(ru.alpha > RUNES_CONFIG.alphaMax || ru.alpha < RUNES_CONFIG.alphaMin){
        ru.aPulse *= -1;
        ru.alpha = Math.max(RUNES_CONFIG.alphaMin, Math.min(RUNES_CONFIG.alphaMax, ru.alpha));
      }

      // Wrap autour des bords
      if(ru.x < -50) ru.x = W + 50;
      if(ru.x > W + 50) ru.x = -50;
      if(ru.y < -50) ru.y = H + 50;
      if(ru.y > H + 50) ru.y = -50;

      // Render (glow léger)
      ctx.save();
      ctx.translate(ru.x, ru.y);
      ctx.rotate(ru.r);
      ctx.font = `${ru.size}px ${RUNES_CONFIG.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Halo
      ctx.globalAlpha = Math.max(0, ru.alpha - 0.15);
      ctx.shadowColor = ru.color;
      ctx.shadowBlur = Math.max(6, ru.size*0.4);
      ctx.fillStyle = ru.color;
      ctx.fillText(ru.glyph, 0, 0);

      // Trace nette
      ctx.shadowBlur = 0;
      ctx.globalAlpha = ru.alpha;
      ctx.fillText(ru.glyph, 0, 0);

      ctx.restore();
    }

    if(!prefersReduced){
      animId = requestAnimationFrame(draw);
    }
  }

  // Pause si l’utilisateur préfère moins d’animations
  if(prefersReduced){
    resize();
  } else {
    const ro = new ResizeObserver(resize);
    ro.observe(hero);
    window.addEventListener('orientationchange', resize, {passive:true});
    resize();
    animId = requestAnimationFrame(draw);
    // Nettoyage si on quitte la page
    window.addEventListener('visibilitychange', () => {
      if(document.hidden){ if(animId) cancelAnimationFrame(animId); animId=null; }
      else if(!animId){ animId = requestAnimationFrame(draw); }
    });
  }
})();
</script>
</body>
</html>
